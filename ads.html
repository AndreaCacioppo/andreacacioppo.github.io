<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ads</title>
  <meta name="description" content="a quiet expanse where the truth cuts through the haze.">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Share Tech Mono', 'Courier New', monospace;
      background: #000;
      color: rgba(0, 255, 65, 0.85);
      min-height: 100vh;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    .back-link {
      position: fixed;
      top: 2rem;
      left: 2rem;
      padding: 0.5rem 1.1rem;
      border-radius: 999px;
      background: rgba(0, 15, 5, 0.7);
      border: 1px solid rgba(0, 255, 65, 0.15);
      color: rgba(0, 255, 65, 0.65);
      font-family: 'Share Tech Mono', 'Courier New', monospace;
      font-size: 0.7rem;
      letter-spacing: 0.15em;
      text-decoration: none;
      text-transform: uppercase;
      transition: color 200ms ease, border-color 200ms ease, transform 200ms ease, text-shadow 200ms ease;
      backdrop-filter: blur(5px);
      z-index: 10;
    }

    .back-link:hover,
    .back-link:focus-visible {
      color: rgba(0, 255, 65, 0.95);
      border-color: rgba(0, 255, 65, 0.4);
      text-shadow: 0 0 6px rgba(0, 255, 65, 0.4);
      transform: translateY(-2px);
      outline: none;
    }

    .back-link:active {
      transform: translateY(0);
    }

    .cat-link {
      position: fixed;
      top: 2rem;
      right: 2rem;
      padding: 0.45rem 0.7rem;
      border-radius: 999px;
      background: rgba(0, 15, 5, 0.7);
      border: 1px solid rgba(0, 255, 65, 0.15);
      color: rgba(0, 255, 65, 0.65);
      text-decoration: none;
      transition: color 200ms ease, border-color 200ms ease, transform 200ms ease, text-shadow 200ms ease;
      backdrop-filter: blur(5px);
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .cat-link:hover,
    .cat-link:focus-visible {
      color: rgba(0, 255, 65, 0.95);
      border-color: rgba(0, 255, 65, 0.4);
      transform: translateY(-2px);
      outline: none;
    }

    .cat-link:hover svg {
      filter: drop-shadow(0 0 4px rgba(0, 255, 65, 0.5));
    }

    .cat-link:active {
      transform: translateY(0);
    }

    .cat-link svg {
      width: 20px;
      height: 20px;
      fill: none;
      stroke: currentColor;
      stroke-width: 1.8;
      stroke-linecap: round;
      stroke-linejoin: round;
      transition: filter 200ms ease;
    }

    @media (max-width: 600px) {
      .back-link {
        top: 1.2rem;
        left: 1.2rem;
        letter-spacing: 0.1em;
      }

      .cat-link {
        top: 1.2rem;
        right: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <a class="back-link" href="/" aria-label="return to the main page">home</a>
  <a class="cat-link" href="/cat.html" aria-label="cat">
    <svg viewBox="0 0 24 24">
      <path d="M3 11 L3 4 L7 8 L12 6 L17 8 L21 4 L21 11"/>
      <ellipse cx="12" cy="15" rx="9" ry="7"/>
      <circle cx="9" cy="14" r="1" fill="currentColor" stroke="none"/>
      <circle cx="15" cy="14" r="1" fill="currentColor" stroke="none"/>
      <path d="M11 16.5 Q12 17.5 13 16.5" stroke-width="1.2"/>
      <line x1="6" y1="15" x2="2" y2="14" stroke-width="1"/>
      <line x1="6" y1="16" x2="2" y2="16.5" stroke-width="1"/>
      <line x1="18" y1="15" x2="22" y2="14" stroke-width="1"/>
      <line x1="18" y1="16" x2="22" y2="16.5" stroke-width="1"/>
    </svg>
  </a>
  <canvas id="grid" aria-hidden="true"></canvas>

  <script>
    // ── Broad ASCII character set for a chaotic, textured grid ──
    // Wide variety of glyphs: digits, letters, symbols, punctuation, math,
    // brackets, slashes -- produces a dense, noisy visual field.
    const CHARS = '0123456789abcdefghijklmnopqrstuvwxyz!@#$%^&*()-_=+[]{}|;:,.<>?/~`ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef0101';

    function randChar() {
      return CHARS[Math.floor(Math.random() * CHARS.length)];
    }

    // ── 5x5 bitmap font for A-Z, space, and basic punctuation ──
    const FONT = {
      'A': ['.###.','#...#','#####','#...#','#...#'],
      'B': ['####.','#...#','####.','#...#','####.'],
      'C': ['.####','#....','#....','#....','.####'],
      'D': ['####.','#...#','#...#','#...#','####.'],
      'E': ['#####','#....','###..','#....','#####'],
      'F': ['#####','#....','###..','#....','#....'],
      'G': ['.####','#....','#.###','#...#','.###.'],
      'H': ['#...#','#...#','#####','#...#','#...#'],
      'I': ['#####','..#..','..#..','..#..','#####'],
      'J': ['..###','...#.','...#.','#..#.','.##..'],
      'K': ['#...#','#..#.','###..','#..#.','#...#'],
      'L': ['#....','#....','#....','#....','#####'],
      'M': ['#...#','##.##','#.#.#','#...#','#...#'],
      'N': ['#...#','##..#','#.#.#','#..##','#...#'],
      'O': ['.###.','#...#','#...#','#...#','.###.'],
      'P': ['####.','#...#','####.','#....','#....'],
      'Q': ['.###.','#...#','#.#.#','#..#.','.##.#'],
      'R': ['####.','#...#','####.','#..#.','#...#'],
      'S': ['.####','#....','.###.','....#','####.'],
      'T': ['#####','..#..','..#..','..#..','..#..'],
      'U': ['#...#','#...#','#...#','#...#','.###.'],
      'V': ['#...#','#...#','.#.#.','.#.#.','..#..'],
      'W': ['#...#','#...#','#.#.#','##.##','#...#'],
      'X': ['#...#','.#.#.','..#..','.#.#.','#...#'],
      'Y': ['#...#','.#.#.','..#..','..#..','..#..'],
      'Z': ['#####','...#.','..#..','.#...','#####'],
      ' ': ['.....','.....','.....','.....','.....'],
      '.': ['.....','.....','.....','.....','..#..'],
      ',': ['.....','.....','.....','..#..','.#...'],
      '!': ['..#..','..#..','..#..','.....','..#..'],
      '?': ['.###.','#...#','..##.','.....','..#..'],
      "'": ['..#..','..#..','.....','.....','.....',],
      '-': ['.....','.....','..#..','.....','.....'],
    };

    const MESSAGE = 'ADVERTISING IS THE MOST TOXIC POLLUTANT IN THE WORLD';
    const CHAR_WIDTH = 5;
    const CHAR_HEIGHT = 5;
    const CHAR_GAP = 1;
    const LINE_GAP = 2;

    const canvas = document.getElementById('grid');
    const ctx = canvas.getContext('2d');
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');

    // ── Grid state ──
    let cols = 0;
    let rows = 0;
    let cellW = 0;
    let cellH = 0;
    let fontSize = 12;

    // Per-cell state
    let cellChars = null;      // flat array of characters
    let cellTimers = null;     // flat Float32Array: ms until next character change
    let cellAlpha = null;      // flat Float32Array: per-cell brightness (0-1 scale)
    let messageMask = null;    // flat Uint8Array: 1 if cell is part of message shape
    let revealedMask = null;   // flat Uint8Array: 1 if cell has been revealed

    function idx(r, c) { return r * cols + c; }

    // ── Timing: slightly slower than before for a quieter feel ──
    // Background cells change at a leisurely pace
    const BG_MIN_MS = 300;
    const BG_MAX_MS = 3000;
    // Message cells change a bit faster but still unhurried
    const MSG_MIN_MS = 120;
    const MSG_MAX_MS = 800;

    function randBgTimer() {
      return BG_MIN_MS + Math.random() * (BG_MAX_MS - BG_MIN_MS);
    }
    function randMsgTimer() {
      return MSG_MIN_MS + Math.random() * (MSG_MAX_MS - MSG_MIN_MS);
    }

    // ── Per-cell background brightness: random value in a range ──
    // Creates spatial variation -- some cells slightly brighter, some dimmer
    // Range: 0.06 to 0.18, centered around 0.13
    function randBgAlpha() {
      return 0.06 + Math.random() * 0.12;
    }

    // Message cell brightness: subtle, close to background but still readable
    // Range: 0.30 to 0.38
    function randMsgAlpha() {
      return 0.30 + Math.random() * 0.08;
    }

    // ── Progressive reveal state ──
    let messageCells = [];
    let revealedCount = 0;
    let fullyRevealed = false;
    let revealAccum = 0;
    const REVEAL_RATE = 18;

    // ── Word-wrap ──
    function wrapMessage(maxCols) {
      const words = MESSAGE.split(' ');
      const lines = [];
      let current = '';

      for (const word of words) {
        const wordW = word.length * (CHAR_WIDTH + CHAR_GAP) - CHAR_GAP;
        const curW = current.length > 0
          ? current.length * (CHAR_WIDTH + CHAR_GAP) - CHAR_GAP
          : 0;
        const spaceW = CHAR_WIDTH + CHAR_GAP;

        if (current.length === 0) {
          current = word;
        } else if (curW + spaceW + wordW <= maxCols) {
          current += ' ' + word;
        } else {
          lines.push(current);
          current = word;
        }
      }
      if (current.length > 0) lines.push(current);
      return lines;
    }

    // ── Build message mask ──
    function buildMessageLayout() {
      messageMask.fill(0);
      revealedMask.fill(0);
      messageCells = [];

      const usableCols = cols - 4;
      const lines = wrapMessage(usableCols);
      const totalRows = lines.length * CHAR_HEIGHT + (lines.length - 1) * LINE_GAP;
      const startRow = Math.max(0, Math.floor((rows - totalRows) / 2));

      for (let li = 0; li < lines.length; li++) {
        const line = lines[li];
        const lineW = line.length * (CHAR_WIDTH + CHAR_GAP) - CHAR_GAP;
        const startCol = Math.max(0, Math.floor((cols - lineW) / 2));
        const rowOff = startRow + li * (CHAR_HEIGHT + LINE_GAP);

        let col = startCol;
        for (let ci = 0; ci < line.length; ci++) {
          const glyph = FONT[line[ci]] || FONT[' '];
          for (let gr = 0; gr < CHAR_HEIGHT; gr++) {
            for (let gc = 0; gc < CHAR_WIDTH; gc++) {
              const r = rowOff + gr;
              const c = col + gc;
              if (r >= 0 && r < rows && c >= 0 && c < cols && glyph[gr][gc] === '#') {
                const i = idx(r, c);
                messageMask[i] = 1;
                messageCells.push(i);
              }
            }
          }
          col += CHAR_WIDTH + CHAR_GAP;
        }
      }

      revealedCount = 0;
      fullyRevealed = false;
      revealAccum = 0;
    }

    // ── Resize and reinitialize ──
    function resize() {
      const dpr = window.devicePixelRatio || 1;
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      canvas.width = vw * dpr;
      canvas.height = vh * dpr;
      canvas.style.width = vw + 'px';
      canvas.style.height = vh + 'px';
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);

      fontSize = Math.max(10, Math.min(14, Math.floor(vw / 100)));
      cellW = fontSize * 0.62;
      cellH = fontSize * 1.2;
      cols = Math.floor(vw / cellW);
      rows = Math.floor(vh / cellH);

      const total = rows * cols;

      cellChars = new Array(total);
      cellTimers = new Float32Array(total);
      cellAlpha = new Float32Array(total);
      messageMask = new Uint8Array(total);
      revealedMask = new Uint8Array(total);

      // Fill with random characters, staggered timers, and varied brightness
      for (let i = 0; i < total; i++) {
        cellChars[i] = randChar();
        cellTimers[i] = Math.random() * BG_MAX_MS;
        cellAlpha[i] = randBgAlpha();
      }

      buildMessageLayout();

      if (prefersReducedMotion.matches) {
        revealedCount = messageCells.length;
        fullyRevealed = true;
        for (let j = 0; j < messageCells.length; j++) {
          const ci = messageCells[j];
          revealedMask[ci] = 1;
          cellAlpha[ci] = randMsgAlpha();
        }
      }
    }

    // ── Main render loop ──
    let lastTime = 0;

    // Pre-build a small cache of rgba strings to avoid string allocation
    // every frame. We quantize alpha to 2 decimal places (0.01 steps).
    const alphaCache = {};
    function rgbaStr(a) {
      // Quantize to nearest 0.01
      const key = (a * 100 + 0.5) | 0;
      if (!alphaCache[key]) {
        alphaCache[key] = 'rgba(0,255,65,' + (key / 100).toFixed(2) + ')';
      }
      return alphaCache[key];
    }

    function render(timestamp) {
      const dt = lastTime === 0 ? 16 : Math.min(timestamp - lastTime, 100);
      lastTime = timestamp;

      const dpr = window.devicePixelRatio || 1;
      const vw = canvas.width / dpr;
      const vh = canvas.height / dpr;
      const total = rows * cols;

      // ── Update cell timers, swap characters, reassign brightness ──
      for (let i = 0; i < total; i++) {
        cellTimers[i] -= dt;
        if (cellTimers[i] <= 0) {
          cellChars[i] = randChar();
          if (revealedMask[i] === 1) {
            cellTimers[i] = randMsgTimer();
            // Reassign message brightness on each change for subtle flicker
            cellAlpha[i] = randMsgAlpha();
          } else {
            cellTimers[i] = randBgTimer();
            // Reassign background brightness for organic spatial variation
            cellAlpha[i] = randBgAlpha();
          }
        }
      }

      // ── Progressive reveal ──
      if (!fullyRevealed) {
        revealAccum += dt;
        while (revealAccum >= REVEAL_RATE && revealedCount < messageCells.length) {
          revealAccum -= REVEAL_RATE;
          const ci = messageCells[revealedCount];
          revealedMask[ci] = 1;
          cellTimers[ci] = randMsgTimer();
          cellAlpha[ci] = randMsgAlpha();
          revealedCount++;
        }
        if (revealedCount >= messageCells.length) {
          fullyRevealed = true;
        }
      }

      // ── Draw ──
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, vw, vh);
      ctx.font = fontSize + "px 'Share Tech Mono','Courier New',monospace";
      ctx.textBaseline = 'top';

      // Draw all cells. Because each cell now has its own alpha, we must
      // set fillStyle per-cell. We use the quantized cache to reduce
      // string allocations.
      for (let r = 0; r < rows; r++) {
        const y = r * cellH;
        const rOff = r * cols;
        for (let c = 0; c < cols; c++) {
          const i = rOff + c;
          ctx.fillStyle = rgbaStr(cellAlpha[i]);
          ctx.fillText(cellChars[i], c * cellW, y);
        }
      }

      requestAnimationFrame(render);
    }

    // ── Static render for reduced-motion ──
    function renderStatic() {
      const dpr = window.devicePixelRatio || 1;
      const vw = canvas.width / dpr;
      const vh = canvas.height / dpr;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, vw, vh);
      ctx.font = fontSize + "px 'Share Tech Mono','Courier New',monospace";
      ctx.textBaseline = 'top';

      for (let r = 0; r < rows; r++) {
        const y = r * cellH;
        const rOff = r * cols;
        for (let c = 0; c < cols; c++) {
          const i = rOff + c;
          ctx.fillStyle = rgbaStr(cellAlpha[i]);
          ctx.fillText(cellChars[i], c * cellW, y);
        }
      }
    }

    // ── Init ──
    resize();

    if (prefersReducedMotion.matches) {
      renderStatic();
    } else {
      lastTime = 0;
      requestAnimationFrame(render);
    }

    // ── Handle resize (debounced) ──
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        resize();
        if (prefersReducedMotion.matches) {
          renderStatic();
        }
      }, 150);
    });

    // ── Handle reduced-motion preference changes ──
    if (typeof prefersReducedMotion.addEventListener === 'function') {
      prefersReducedMotion.addEventListener('change', () => {
        resize();
        if (prefersReducedMotion.matches) {
          renderStatic();
        } else {
          lastTime = 0;
          requestAnimationFrame(render);
        }
      });
    } else if (typeof prefersReducedMotion.addListener === 'function') {
      prefersReducedMotion.addListener(() => {
        resize();
        if (prefersReducedMotion.matches) {
          renderStatic();
        } else {
          lastTime = 0;
          requestAnimationFrame(render);
        }
      });
    }
  </script>
</body>
</html>
