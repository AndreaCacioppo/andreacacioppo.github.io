<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>bio</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; cursor: none; }
  canvas { display: block; }

  .back-link {
    position: fixed;
    top: 2rem;
    left: 2rem;
    padding: 0.45rem 0.7rem;
    border-radius: 999px;
    background: rgba(0, 5, 15, 0.7);
    border: 1px solid rgba(30, 80, 120, 0.2);
    color: rgba(40, 90, 130, 0.6);
    text-decoration: none;
    transition: color 200ms ease, border-color 200ms ease, transform 200ms ease;
    backdrop-filter: blur(5px);
    z-index: 10;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .back-link:hover,
  .back-link:focus-visible {
    color: rgba(60, 150, 200, 0.9);
    border-color: rgba(40, 100, 160, 0.4);
    transform: translateY(-2px);
    outline: none;
  }

  .back-link:hover svg {
    filter: drop-shadow(0 0 6px rgba(60, 150, 200, 0.5));
  }

  .back-link:active {
    transform: translateY(0);
  }

  .back-link svg {
    width: 22px;
    height: 22px;
    fill: none;
    stroke: currentColor;
    stroke-linecap: round;
    stroke-linejoin: round;
    animation: spin-star 12s linear infinite;
    transition: filter 200ms ease;
  }

  @keyframes spin-star {
    from { transform: rotate(0deg); }
    to   { transform: rotate(360deg); }
  }

  .forward-link {
    position: fixed;
    top: 2rem;
    right: 2rem;
    padding: 0.45rem 0.7rem;
    border-radius: 999px;
    background: rgba(0, 5, 15, 0.7);
    border: 1px solid rgba(30, 80, 120, 0.2);
    color: rgba(40, 90, 130, 0.6);
    text-decoration: none;
    transition: color 200ms ease, border-color 200ms ease, transform 200ms ease;
    backdrop-filter: blur(5px);
    z-index: 10;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .forward-link:hover,
  .forward-link:focus-visible {
    color: rgba(60, 150, 200, 0.9);
    border-color: rgba(40, 100, 160, 0.4);
    transform: translateY(-2px);
    outline: none;
  }

  .forward-link:hover svg {
    filter: drop-shadow(0 0 6px rgba(60, 150, 200, 0.5));
  }

  .forward-link:active {
    transform: translateY(0);
  }

  .forward-link svg {
    width: 22px;
    height: 22px;
    fill: none;
    stroke: currentColor;
    stroke-width: 1.4;
    stroke-linecap: round;
    stroke-linejoin: round;
    transition: filter 200ms ease;
  }

  @media (max-width: 600px) {
    .back-link {
      top: 1.2rem;
      left: 1.2rem;
    }
    .forward-link {
      top: 1.2rem;
      right: 1.2rem;
    }
  }
</style>
</head>
<body>
<a class="back-link" href="/van.html" aria-label="return to starry night page">
  <svg viewBox="0 0 24 24" stroke-width="1.6">
    <circle cx="12" cy="12" r="3" stroke-width="1.6"/>
    <circle cx="12" cy="12" r="6.5" stroke-width="0.9" stroke-dasharray="3.5 2.5" stroke-dashoffset="1"/>
    <circle cx="12" cy="12" r="10" stroke-width="0.7" stroke-dasharray="4 3.5" stroke-dashoffset="3"/>
    <path d="M12 1.5 C12.3 4, 11.7 4, 12 5" stroke-width="0.8"/>
    <path d="M12 22.5 C11.7 20, 12.3 20, 12 19" stroke-width="0.8"/>
    <path d="M1.5 12 C4 12.3, 4 11.7, 5 12" stroke-width="0.8"/>
    <path d="M22.5 12 C20 11.7, 20 12.3, 19 12" stroke-width="0.8"/>
    <path d="M4.2 4.2 C5.5 5.8, 6 5.3, 6.8 6.8" stroke-width="0.7"/>
    <path d="M19.8 4.2 C18.5 5.8, 18 5.3, 17.2 6.8" stroke-width="0.7"/>
    <path d="M4.2 19.8 C5.5 18.2, 6 18.7, 6.8 17.2" stroke-width="0.7"/>
    <path d="M19.8 19.8 C18.5 18.2, 18 18.7, 17.2 17.2" stroke-width="0.7"/>
  </svg>
</a>
<a class="forward-link" href="/topo.html" aria-label="topographic map">
  <svg viewBox="0 0 24 24">
    <ellipse cx="12" cy="12" rx="3" ry="2"/>
    <ellipse cx="12" cy="12" rx="6" ry="4.5"/>
    <ellipse cx="12" cy="12" rx="9.5" ry="7"/>
  </svg>
</a>
<canvas id="c"></canvas>
<script>
// Realistic ocean-at-night ASCII simulation with bioluminescent mouse interaction.
// Renders a top-down view of wind-driven swells, cross-chop, moderate foam,
// gentle moonlight reflection, and interactive bioluminescence ripples.
// Dark ocean with clearly visible wave texture; bioluminescence still dominates.
// Wave frequencies tuned so the surface always feels alive -- no dead zones.

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let CHAR_W = 11;
let CHAR_H = 17;
let FONT_SIZE = 14;
let FONT = `${FONT_SIZE}px "Courier New", monospace`;

let W, H, cols, rows;
let glowA, glowB; // double-buffered glow grids
let useA = true;

// Mouse state
let mx = -1, my = -1, pmx = -1, pmy = -1;
let speed = 0;
let time = 0;
let frameCount = 0;

// Characters grouped by visual weight: calm water -> mid wave -> crest/foam
// Even calm areas show faint texture -- only one space in the calm set
const charsCalm  = [' ', '\u00B7', '\u00B7', '.', '.'];        // troughs: faint dots, one space
const charsMid   = ['\u00B7', '-', '~', '\u2248', '\u223F'];   // mid-wave: visible ripple texture
const charsCrest = ['~', '\u2248', '\u2591', '\u2591', '*'];    // crests: block chars for strongest peaks

function resize() {
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  // Scale character size for smaller screens
  FONT_SIZE = Math.max(8, Math.min(14, Math.round(W / 85)));
  CHAR_W = Math.round(FONT_SIZE * 0.79);
  CHAR_H = Math.round(FONT_SIZE * 1.21);
  FONT = `${FONT_SIZE}px "Courier New", monospace`;
  cols = Math.ceil(W / CHAR_W) + 1;
  rows = Math.ceil(H / CHAR_H) + 1;
  const size = cols * rows;
  glowA = new Float32Array(size);
  glowB = new Float32Array(size);
  ripples.length = 0;
}

// --- Sea simulation ---
// Produces broad directional swells with smaller cross-chop layered on top.
// Frequencies are high enough that multiple wave ridges are always visible.
// Returns a value roughly in -1..1 range.

function seaHeight(x, y, t) {
  let h = 0;

  // Primary swell: rolling waves moving diagonally (NW to SE direction)
  // Tighter spacing than before so ridges appear every ~35 cells instead of ~55
  const swellAngle = 0.4;
  const sx = x * Math.cos(swellAngle) + y * Math.sin(swellAngle);
  h += Math.sin(sx * 0.03 + t * 0.4) * 0.38;
  // Second harmonic for rounder wave shapes
  h += Math.sin(sx * 0.06 + t * 0.8 + 0.8) * 0.13;

  // Secondary swell: cross-swell at a different angle, also tighter
  const swell2Angle = -0.6;
  const sx2 = x * Math.cos(swell2Angle) + y * Math.sin(swell2Angle);
  h += Math.sin(sx2 * 0.022 + t * 0.28 + 2.0) * 0.22;

  // Wind chop: shorter, faster waves -- bumped up in frequency and amplitude
  const chopAngle = 0.2;
  const cx = x * Math.cos(chopAngle) + y * Math.sin(chopAngle);
  h += Math.sin(cx * 0.10 + t * 1.2) * 0.13;
  h += Math.sin(cx * 0.15 - t * 0.95 + 1.5) * 0.08;

  // Cross-chop: perpendicular to wind, denser texture
  const crossAngle = chopAngle + 1.3;
  const ccx = x * Math.cos(crossAngle) + y * Math.sin(crossAngle);
  h += Math.sin(ccx * 0.12 + t * 1.0 + 3.0) * 0.09;
  h += Math.sin(ccx * 0.19 + t * 1.4 + 0.5) * 0.06;

  // Fine surface ripples: high-frequency detail that fills gaps
  h += Math.sin(x * 0.22 + y * 0.12 + t * 1.8) * 0.05;
  h += Math.sin(x * 0.14 - y * 0.18 - t * 0.6 + 4.0) * 0.04;
  h += Math.sin(x * 0.30 + y * 0.05 + t * 2.2 + 1.0) * 0.03;

  return h;
}

// Derivative of sea height for detecting crests (used for whitecap/foam)
// Approximated by sampling nearby points
function seaCrestiness(x, y, t) {
  const h  = seaHeight(x, y, t);
  const hx = seaHeight(x + 0.5, y, t);
  const hy = seaHeight(x, y + 0.5, t);
  // Curvature approximation: how "peaked" is this point?
  const dx = hx - h;
  const dy = hy - h;
  // Also check if we're near the top of a wave (height above a threshold)
  const peakness = Math.max(0, h - 0.15); // lowered from 0.25 so more peaks qualify
  // Combine gradient magnitude with peak height
  return peakness * 2.5 + Math.max(0, -dx - dy) * 0.8;
}

// Current field for advecting bioluminescence
function currentFieldX(x, y, t) {
  return 0.02 + Math.sin(y * 0.04 + t * 0.18) * 0.015 + Math.sin(x * 0.03 + t * 0.1) * 0.01;
}

function currentFieldY(x, y, t) {
  return Math.sin(x * 0.035 + t * 0.12) * 0.01 + Math.cos(y * 0.05 + t * 0.15) * 0.007;
}

// Pick character based on wave height and crestiness
function pickChar(height, crest) {
  // Normalize height from roughly -1..1 to 0..1
  const norm = (height + 1) * 0.5;

  // Lowered crest threshold so foam appears more readily
  if (crest > 0.35) {
    const ci = Math.min(charsCrest.length - 1, Math.floor((crest - 0.35) * 3.5));
    return charsCrest[ci];
  } else if (norm > 0.45) {
    // Mid-wave threshold lowered from 0.55 so more surface shows texture
    const ci = Math.floor((norm - 0.45) / 0.55 * (charsMid.length - 0.01));
    return charsMid[Math.max(0, Math.min(charsMid.length - 1, ci))];
  } else {
    // Calm/trough: faint texture instead of empty
    const ci = Math.floor(norm / 0.45 * (charsCalm.length - 0.01));
    return charsCalm[Math.max(0, Math.min(charsCalm.length - 1, ci))];
  }
}

// Color for the sea: dark but clearly visible wave texture
// Troughs are very dark, mid-tones are visible dark teal, crests have moderate pop
function seaColor(height, crest, moonlight) {
  const norm = (height + 1) * 0.5; // 0..1

  let r, g, b;

  if (crest > 0.35) {
    // Foam/crests: moderate brightness, teal-white with some pop
    const foamI = Math.min(1.0, (crest - 0.35) * 1.6);
    r = 40 + foamI * 40 | 0;    // range ~40-80
    g = 60 + foamI * 40 | 0;    // range ~60-100
    b = 80 + foamI * 50 | 0;    // range ~80-130
  } else if (norm > 0.45) {
    // Mid-to-upper wave: clearly visible dark teal/navy
    const t = (norm - 0.45) / 0.55;
    r = 10 + t * 15  | 0;   // range ~10-25
    g = 25 + t * 25  | 0;   // range ~25-50
    b = 50 + t * 35  | 0;   // range ~50-85
  } else {
    // Deep troughs: very dark but not pure black
    const t = norm / 0.45;
    r = 3  + t * 5   | 0;   // range ~3-8
    g = 8  + t * 10  | 0;   // range ~8-18
    b = 20 + t * 20  | 0;   // range ~20-40
  }

  // Apply moonlight boost -- gentle shimmer, noticeable but not dominant
  if (moonlight > 0) {
    const ml = moonlight * 0.4;
    r = Math.min(255, r + ml * 22 | 0);
    g = Math.min(255, g + ml * 32 | 0);
    b = Math.min(255, b + ml * 40 | 0);
  }

  return [r, g, b];
}

// Moonlight reflection: a gentle shimmering band across the surface
// Noticeable but not dominant -- a soft shimmer
function moonlightIntensity(col, row, t) {
  // Moon position shifts slowly over time for a living feel
  const moonCol = cols * 0.55 + Math.sin(t * 0.03) * cols * 0.05;

  // Vertical streak with some wave distortion
  const distFromCenter = Math.abs(col - moonCol);
  // The reflection narrows toward the "horizon" (top of screen) and widens near bottom
  const rowFactor = 0.3 + (row / rows) * 0.7; // wider at bottom
  const bandWidth = 4 + rowFactor * 8;

  if (distFromCenter > bandWidth) return 0;

  // Core brightness: Gaussian-ish falloff from center of band
  const bandNorm = distFromCenter / bandWidth;
  let intensity = Math.exp(-bandNorm * bandNorm * 3.0);

  // Add shimmer: the reflection breaks up on the wave surface
  const shimmer = Math.sin(col * 0.3 + row * 0.15 + t * 1.2) * 0.3
                + Math.sin(col * 0.17 - row * 0.22 + t * 0.7) * 0.2
                + Math.sin(col * 0.5 + t * 2.0 + row * 0.08) * 0.15;

  // Reflection is stronger on wave crests (height-dependent)
  const h = seaHeight(col, row, t);
  const heightBoost = Math.max(0, (h + 1) * 0.5 - 0.3) * 1.2;

  intensity *= (0.5 + shimmer * 0.5) * (0.6 + heightBoost * 0.4);

  // Sparkle: occasional glints
  const sparkle = Math.sin(col * 1.7 + row * 2.3 + t * 3.5);
  if (sparkle > 0.93) {
    intensity *= 1.5;
  }

  // Moderate final multiplier: visible shimmer without overpowering
  return Math.max(0, Math.min(1, intensity * 0.45));
}

// --- Bioluminescence ---

const DECAY = 0.955;          // per-frame decay for the residual trail
const SPREAD = 0.008;         // very subtle diffusion
const MOUSE_RADIUS = 1.5;     // thin direct trace
const MAX_GLOW = 1.5;

// Ripple system
const MAX_RIPPLES = 120;
const RIPPLE_SPEED = 0.25;     // cells per frame expansion
const RIPPLE_DECAY = 0.45;     // exponential decay rate per radius unit
const RIPPLE_WIDTH = 1.8;      // ring thickness in cells
const RIPPLE_MAX_RADIUS = 35;  // max expansion before removal

const ripples = [];

function spawnRipple(col, row, intensity) {
  if (ripples.length >= MAX_RIPPLES) ripples.shift();
  ripples.push({ col, row, radius: 0.5, intensity, age: 0 });
}

function addGlow(col, row, intensity) {
  const src = useA ? glowA : glowB;
  const r2 = MOUSE_RADIUS;
  for (let dy = -2; dy <= 2; dy++) {
    for (let dx = -2; dx <= 2; dx++) {
      const c = col + dx, r = row + dy;
      if (c < 0 || c >= cols || r < 0 || r >= rows) continue;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > r2) continue;
      const falloff = 1 - dist / (r2 + 0.5);
      const idx = r * cols + c;
      src[idx] = Math.min(MAX_GLOW, src[idx] + intensity * falloff * falloff);
    }
  }
}

function updateRipples() {
  const src = useA ? glowA : glowB;

  for (let i = ripples.length - 1; i >= 0; i--) {
    const rip = ripples[i];
    rip.radius += RIPPLE_SPEED;
    rip.age++;

    if (rip.radius > RIPPLE_MAX_RADIUS) {
      ripples.splice(i, 1);
      continue;
    }

    // Exponential decay with radius
    const ringIntensity = rip.intensity * Math.exp(-RIPPLE_DECAY * rip.radius);
    if (ringIntensity < 0.003) {
      ripples.splice(i, 1);
      continue;
    }

    // Only iterate over cells near the ring
    const rMin = Math.max(0, Math.floor(rip.row - rip.radius - 2));
    const rMax = Math.min(rows - 1, Math.ceil(rip.row + rip.radius + 2));
    const cMin = Math.max(0, Math.floor(rip.col - rip.radius - 2));
    const cMax = Math.min(cols - 1, Math.ceil(rip.col + rip.radius + 2));

    for (let r = rMin; r <= rMax; r++) {
      for (let c = cMin; c <= cMax; c++) {
        const dx = c - rip.col;
        const dy = r - rip.row;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const ringDist = Math.abs(dist - rip.radius);

        if (ringDist < RIPPLE_WIDTH) {
          // Smooth ring profile (Gaussian-ish)
          const profile = Math.exp(-(ringDist * ringDist) / (RIPPLE_WIDTH * 0.5));
          const idx = r * cols + c;
          src[idx] = Math.min(MAX_GLOW, src[idx] + ringIntensity * profile * 0.4);
        }
      }
    }
  }
}

function advectAndDecayGlow() {
  // First apply ripples to current buffer
  updateRipples();

  const src = useA ? glowA : glowB;
  const dst = useA ? glowB : glowA;
  dst.fill(0);

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const cx = currentFieldX(c, r, time);
      const cy = currentFieldY(c, r, time);
      const srcX = c - cx;
      const srcY = r - cy;

      const x0 = Math.floor(srcX), y0 = Math.floor(srcY);
      const fx = srcX - x0, fy = srcY - y0;

      let val = 0;
      for (let oy = 0; oy <= 1; oy++) {
        for (let ox = 0; ox <= 1; ox++) {
          const sc = x0 + ox, sr = y0 + oy;
          if (sc >= 0 && sc < cols && sr >= 0 && sr < rows) {
            const weight = (ox ? fx : 1 - fx) * (oy ? fy : 1 - fy);
            val += src[sr * cols + sc] * weight;
          }
        }
      }

      let neighbors = 0, nCount = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nc = c + dx, nr = r + dy;
          if (nc >= 0 && nc < cols && nr >= 0 && nr < rows) {
            neighbors += src[nr * cols + nc];
            nCount++;
          }
        }
      }

      const diffused = nCount > 0 ? neighbors / nCount : 0;
      val = val * (1 - SPREAD) + diffused * SPREAD;

      dst[r * cols + c] = val * DECAY;
    }
  }

  useA = !useA;
}

// --- Rendering ---

function render() {
  time += 0.018;
  frameCount++;

  // Process mouse input
  if (mx >= 0 && pmx >= 0) {
    const dx = mx - pmx, dy = my - pmy;
    speed = Math.sqrt(dx * dx + dy * dy);
    const intensity = Math.min(speed * 0.04, 1.2);

    if (intensity > 0.005) {
      const col = Math.floor(mx / CHAR_W);
      const row = Math.floor(my / CHAR_H);
      addGlow(col, row, intensity * 0.7);

      // Spawn ripple -- throttle to avoid flooding
      if (frameCount % 3 === 0 || speed > 15) {
        spawnRipple(col, row, intensity);
      }

      // Interpolate along fast movements
      if (speed > CHAR_W) {
        const steps = Math.ceil(speed / CHAR_W);
        for (let s = 1; s < steps; s++) {
          const t = s / steps;
          const ic = Math.floor((pmx + dx * t) / CHAR_W);
          const ir = Math.floor((pmy + dy * t) / CHAR_H);
          addGlow(ic, ir, intensity * 0.5 * (1 - t * 0.3));
        }
      }
    }
  }
  pmx = mx; pmy = my;

  // Advect bioluminescence with currents
  advectAndDecayGlow();

  const glow = useA ? glowA : glowB;

  // Clear to black
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);
  ctx.font = FONT;
  ctx.textBaseline = 'top';

  for (let r = 0; r < rows; r++) {
    const py = r * CHAR_H;
    if (py > H) break;
    for (let c = 0; c < cols; c++) {
      const px = c * CHAR_W;
      if (px > W) break;

      const h = seaHeight(c, r, time);
      const crest = seaCrestiness(c, r, time);
      const moon = moonlightIntensity(c, r, time);
      const ch = pickChar(h, crest);
      if (ch === ' ') continue; // skip empty cells for performance

      const g = glow[r * cols + c];
      const [br, bg, bb] = seaColor(h, crest, moon);

      let red, green, blue;
      if (g > 0.005) {
        // Bioluminescence color: electric cyan-blue
        // Two-tone glow: core is white-cyan, outer is electric blue
        const g2 = Math.min(g, 1.0);
        const g3 = g2 * g2; // quadratic for more pop

        // Electric blue target: rgb(50, 210, 255) with white core
        const glowR = 30 + g3 * 200;
        const glowG = 190 + g3 * 65;
        const glowB = 255;

        red   = br + (glowR - br) * g2 | 0;
        green = bg + (glowG - bg) * g2 | 0;
        blue  = bb + (glowB - bb) * g2 | 0;

        // Clamp
        red = Math.min(255, red);
        green = Math.min(255, green);
        blue = Math.min(255, blue);
      } else {
        red = br; green = bg; blue = bb;
      }

      ctx.fillStyle = `rgb(${red},${green},${blue})`;
      ctx.fillText(ch, px, py);
    }
  }

  requestAnimationFrame(render);
}

// --- Events ---

window.addEventListener('resize', resize);

canvas.addEventListener('mousemove', e => {
  mx = e.clientX;
  my = e.clientY;
});

canvas.addEventListener('mouseleave', () => {
  mx = my = pmx = pmy = -1;
  speed = 0;
});

// Touch support
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const t = e.touches[0];
  mx = t.clientX;
  my = t.clientY;
}, { passive: false });

canvas.addEventListener('touchend', () => {
  mx = my = pmx = pmy = -1;
  speed = 0;
});

resize();
requestAnimationFrame(render);
</script>
</body>
</html>
