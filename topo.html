<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>topo</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; }
  canvas { display: block; }

  .nav-link {
    position: fixed;
    top: 2rem;
    padding: 0.45rem 0.7rem;
    border-radius: 999px;
    background: rgba(5, 12, 5, 0.75);
    border: 1px solid rgba(50, 90, 40, 0.25);
    color: rgba(80, 130, 60, 0.65);
    text-decoration: none;
    transition: color 200ms ease, border-color 200ms ease, transform 200ms ease;
    backdrop-filter: blur(5px);
    z-index: 10;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .nav-link:hover,
  .nav-link:focus-visible {
    color: rgba(120, 180, 80, 0.9);
    border-color: rgba(80, 140, 50, 0.45);
    transform: translateY(-2px);
    outline: none;
  }

  .nav-link:hover svg {
    filter: drop-shadow(0 0 6px rgba(100, 170, 60, 0.5));
  }

  .nav-link:active {
    transform: translateY(0);
  }

  .nav-link svg {
    width: 22px;
    height: 22px;
    fill: none;
    stroke: currentColor;
    stroke-linecap: round;
    stroke-linejoin: round;
    transition: filter 200ms ease;
  }

  .nav-back { left: 2rem; }
  .nav-forward { right: 2rem; }

  @media (max-width: 600px) {
    .nav-link {
      top: 1.2rem;
    }
    .nav-back { left: 1.2rem; }
    .nav-forward { right: 1.2rem; }
  }
</style>
</head>
<body>
<a class="nav-link nav-back" href="/bio.html" aria-label="back to bioluminescent ocean">
  <svg viewBox="0 0 24 24" stroke-width="1.6">
    <path d="M2 12 C4 9, 6 9, 8 12 S12 15, 14 12 S18 9, 20 12"/>
    <path d="M2 16 C4 13, 6 13, 8 16 S12 19, 14 16 S18 13, 20 16" stroke-width="1.2" opacity="0.6"/>
    <path d="M2 8 C4 5, 6 5, 8 8 S12 11, 14 8 S18 5, 20 8" stroke-width="1.0" opacity="0.4"/>
  </svg>
</a>
<a class="nav-link nav-forward" href="/fractal.html" aria-label="forward to fractal page">
  <svg viewBox="0 0 24 24" stroke-width="1.5">
    <path d="M12 12 C12 9, 15 9, 15 12 C15 16, 8 16, 8 12 C8 7, 17 7, 17 12 C17 18, 6 18, 6 12 C6 5, 19 5, 19 12"/>
  </svg>
</a>
<canvas id="c"></canvas>
<script>
// ASCII topographic map viewed from above, continuously scrolling left.
// Uses value noise with fractal Brownian motion for terrain generation.
// Renders contour lines and elevation-colored fill on a dark background.

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// Character cell dimensions
let CHAR_W = 10;
let CHAR_H = 16;
let FONT_SIZE = 13;
let FONT = `${FONT_SIZE}px "Courier New", monospace`;

let W, H, cols, rows;

// Scroll offset (in noise-space units) — increases over time as camera moves right
let scrollX = 0;

// Time for terrain evolution (slowly changing landscape)
let evolveTime = 0;

// Animation time
let time = 0;

// Timestamp for delta-time calculation (set on first frame)
let lastFrameTime = 0;

// --- Permutation table for value noise ---
// Pre-generated permutation table (256 entries, repeated)
const PERM_SIZE = 256;
const perm = new Uint8Array(512);
const gradValues = new Float32Array(PERM_SIZE);

// Seed the permutation table
(function initNoise() {
  // Simple seeded PRNG (xorshift)
  let seed = 42;
  function rand() {
    seed ^= seed << 13;
    seed ^= seed >> 17;
    seed ^= seed << 5;
    return (seed >>> 0) / 4294967296;
  }

  // Fill permutation
  const p = new Uint8Array(PERM_SIZE);
  for (let i = 0; i < PERM_SIZE; i++) p[i] = i;
  // Fisher-Yates shuffle
  for (let i = PERM_SIZE - 1; i > 0; i--) {
    const j = (rand() * (i + 1)) | 0;
    const tmp = p[i]; p[i] = p[j]; p[j] = tmp;
  }
  for (let i = 0; i < 512; i++) perm[i] = p[i & 255];

  // Random gradient values for value noise
  for (let i = 0; i < PERM_SIZE; i++) {
    gradValues[i] = rand() * 2 - 1;
  }
})();

// --- Value noise (2D) with smooth interpolation ---
// Returns a value roughly in [-1, 1]

function fade(t) {
  // Quintic smoothstep: 6t^5 - 15t^4 + 10t^3
  return t * t * t * (t * (t * 6 - 15) + 10);
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function hash2(ix, iy) {
  return perm[(perm[ix & 255] + iy) & 511];
}

function valueNoise2D(x, y) {
  const ix = Math.floor(x);
  const iy = Math.floor(y);
  const fx = x - ix;
  const fy = y - iy;

  const u = fade(fx);
  const v = fade(fy);

  // Four corner values
  const v00 = gradValues[hash2(ix, iy) & 255];
  const v10 = gradValues[hash2(ix + 1, iy) & 255];
  const v01 = gradValues[hash2(ix, iy + 1) & 255];
  const v11 = gradValues[hash2(ix + 1, iy + 1) & 255];

  return lerp(
    lerp(v00, v10, u),
    lerp(v01, v11, u),
    v
  );
}

// --- 3D value noise for time-evolution ---
function hash3(ix, iy, iz) {
  return perm[(perm[(perm[ix & 255] + iy) & 511] + iz) & 511];
}

function valueNoise3D(x, y, z) {
  const ix = Math.floor(x);
  const iy = Math.floor(y);
  const iz = Math.floor(z);
  const fx = x - ix;
  const fy = y - iy;
  const fz = z - iz;

  const u = fade(fx);
  const v = fade(fy);
  const w = fade(fz);

  // Eight corner values
  const v000 = gradValues[hash3(ix, iy, iz) & 255];
  const v100 = gradValues[hash3(ix + 1, iy, iz) & 255];
  const v010 = gradValues[hash3(ix, iy + 1, iz) & 255];
  const v110 = gradValues[hash3(ix + 1, iy + 1, iz) & 255];
  const v001 = gradValues[hash3(ix, iy, iz + 1) & 255];
  const v101 = gradValues[hash3(ix + 1, iy, iz + 1) & 255];
  const v011 = gradValues[hash3(ix, iy + 1, iz + 1) & 255];
  const v111 = gradValues[hash3(ix + 1, iy + 1, iz + 1) & 255];

  const x00 = lerp(v000, v100, u);
  const x10 = lerp(v010, v110, u);
  const x01 = lerp(v001, v101, u);
  const x11 = lerp(v011, v111, u);

  const y0 = lerp(x00, x10, v);
  const y1 = lerp(x01, x11, v);

  return lerp(y0, y1, w);
}

// --- Fractal Brownian Motion (fbm) using 3D noise ---
// Multiple octaves for detailed, natural-looking terrain
// The z dimension is used for slow time evolution

function fbm(x, y, z, octaves) {
  let value = 0;
  let amplitude = 1.0;
  let frequency = 1.0;
  let maxAmp = 0;

  for (let i = 0; i < octaves; i++) {
    value += valueNoise3D(x * frequency, y * frequency, z * frequency) * amplitude;
    maxAmp += amplitude;
    amplitude *= 0.5;   // persistence
    frequency *= 2.0;   // lacunarity
  }

  return value / maxAmp; // normalize to roughly [-1, 1]
}

// --- Terrain height function ---
// Combines multiple fbm layers for varied features:
// large-scale mountains/valleys + ridges + fine detail

function terrainHeight(wx, wy, t) {
  // Scale factors control feature size
  const scale = 0.035;     // base terrain scale
  const evolve = t * 0.08; // slow evolution speed

  // Base terrain: broad hills and valleys (6 octaves)
  let h = fbm(wx * scale, wy * scale, evolve, 6) * 0.7;

  // Ridge layer: use absolute value of noise to create sharp ridges
  const ridge = Math.abs(fbm(wx * scale * 1.5 + 100, wy * scale * 1.5, evolve * 0.7 + 50, 4));
  h += (1.0 - ridge) * 0.25; // invert so ridges are peaks

  // Fine detail layer
  h += fbm(wx * scale * 3 + 200, wy * scale * 3 + 200, evolve * 0.5 + 100, 3) * 0.12;

  // Normalize to 0..1 range approximately
  // The raw range is roughly -1 to 1.3, so map it
  h = (h + 0.8) / 1.8;
  h = Math.max(0, Math.min(1, h));

  return h;
}

// --- Heightmap buffer (circular) ---
// Circular buffer avoids copying the entire array on each scroll step.
// hmHead tracks which physical column index maps to logical column 0.

let hmBuf;         // Float32Array of size hmCols * rows (row-major)
let hmCols;        // buffer width (cols + 3 for interpolation margin)
let hmHead = 0;    // physical column of logical column 0

// Fractional scroll position within a cell
let subPixelX = 0;

// The world-x coordinate of the leftmost logical column
let worldLeftCol = 0;

function getHM(logicalCol, r) {
  const physC = (hmHead + logicalCol) % hmCols;
  return hmBuf[r * hmCols + physC];
}

function computePhysCol(physC, worldX) {
  for (let r = 0; r < rows; r++) {
    hmBuf[r * hmCols + physC] = terrainHeight(worldX, r, evolveTime);
  }
}

function initHeightMap() {
  hmCols = cols + 3;
  hmBuf = new Float32Array(hmCols * rows);
  hmHead = 0;
  worldLeftCol = Math.floor(scrollX);
  subPixelX = scrollX - worldLeftCol;

  for (let c = 0; c < hmCols; c++) {
    computePhysCol(c, worldLeftCol + c);
  }
}

// Advance by one cell: recycle the oldest column for the new rightmost one
function advanceHeightMap() {
  const recycled = hmHead;
  worldLeftCol++;
  hmHead = (hmHead + 1) % hmCols;
  computePhysCol(recycled, worldLeftCol + hmCols - 1);
}

// --- Contour and character selection ---

// Number of contour levels (more levels = smoother elevation transitions)
const NUM_CONTOURS = 20;
const CONTOUR_STEP = 1.0 / NUM_CONTOURS;

// Characters for fill between contour lines, by elevation band (low to high)
const fillChars = [
  '~',      // 0  - deep water
  '~',      // 1  - deep water
  '\u2248', // 2  - mid water (≈)
  '\u2248', // 3  - shallow water (≈)
  ',',      // 4  - shoreline
  ',',      // 5  - marsh
  ';',      // 6  - low grassland
  ';',      // 7  - grassland
  '!',      // 8  - tall grass
  '\u00A7', // 9  - shrubland (§)
  '%',      // 10 - light forest
  '%',      // 11 - forest
  '#',      // 12 - dense forest
  '#',      // 13 - rocky
  '=',      // 14 - rock face
  '=',      // 15 - steep rock
  '\u2593', // 16 - high rock (▓)
  '\u2592', // 17 - high altitude (▒)
  '\u2592', // 18 - near summit (▒)
  '\u2588', // 19 - peak/snow (█)
];

// Contour line characters
const CONTOUR_H = '\u2500';  // horizontal ─
const CONTOUR_V = '\u2502';  // vertical │
const CONTOUR_TL = '\u256D'; // top-left corner ╭
const CONTOUR_TR = '\u256E'; // top-right corner ╮
const CONTOUR_BL = '\u2570'; // bottom-left corner ╰
const CONTOUR_BR = '\u256F'; // bottom-right corner ╯
const CONTOUR_FWD = '\u2571'; // forward slash ╱ (used for diagonal NE-SW)
const CONTOUR_BWD = '\u2572'; // backslash ╲ (used for diagonal NW-SE)

function getContourBand(h) {
  return Math.min(NUM_CONTOURS - 1, Math.floor(h * NUM_CONTOURS));
}

// Determine if a cell is on a contour boundary and what character to use
function contourChar(band, bandL, bandR, bandU, bandD) {
  // A cell is a contour boundary if any neighbor has a different band
  const diffL = bandL !== band;
  const diffR = bandR !== band;
  const diffU = bandU !== band;
  const diffD = bandD !== band;

  if (!diffL && !diffR && !diffU && !diffD) return null; // no contour

  const horiz = diffL || diffR;
  const vert = diffU || diffD;

  if (horiz && vert) {
    // Corner — determine which type
    if (diffU && diffR && !diffD && !diffL) return CONTOUR_BL;  // ╰
    if (diffU && diffL && !diffD && !diffR) return CONTOUR_BR;  // ╯
    if (diffD && diffR && !diffU && !diffL) return CONTOUR_TL;  // ╭
    if (diffD && diffL && !diffU && !diffR) return CONTOUR_TR;  // ╮
    // Diagonal-ish cases
    if (diffU && diffR) return CONTOUR_FWD;
    if (diffD && diffL) return CONTOUR_FWD;
    if (diffU && diffL) return CONTOUR_BWD;
    if (diffD && diffR) return CONTOUR_BWD;
    // Fallback
    return CONTOUR_H;
  } else if (horiz) {
    return CONTOUR_V; // boundary on left/right = vertical contour line
  } else {
    return CONTOUR_H; // boundary on top/bottom = horizontal contour line
  }
}

// --- Color scheme ---
// Topographic colors: deep green (valleys) -> yellow-green -> tan/brown -> gray -> white (peaks)
// All on a dark background

// Color stops for elevation (0 = lowest, 1 = highest)
const colorStops = [
  { h: 0.00, r: 10,  g: 25,  b: 60  },  // deep water (dark blue)
  { h: 0.12, r: 20,  g: 50,  b: 90  },  // shallow water (blue)
  { h: 0.18, r: 30,  g: 70,  b: 55  },  // shoreline (teal-green)
  { h: 0.25, r: 30,  g: 80,  b: 30  },  // lowland (green)
  { h: 0.35, r: 50,  g: 100, b: 35  },  // grassland (bright green)
  { h: 0.45, r: 80,  g: 110, b: 40  },  // shrubland (yellow-green)
  { h: 0.55, r: 120, g: 100, b: 45  },  // forest/hills (olive)
  { h: 0.65, r: 140, g: 105, b: 55  },  // rocky hills (brown)
  { h: 0.75, r: 130, g: 110, b: 90  },  // mountain rock (gray-brown)
  { h: 0.85, r: 160, g: 155, b: 150 },  // high altitude (gray)
  { h: 0.93, r: 210, g: 210, b: 215 },  // snow line (light gray)
  { h: 1.00, r: 250, g: 250, b: 255 },  // peak snow (white)
];

function getTerrainColor(h) {
  // Clamp height
  h = Math.max(0, Math.min(1, h));

  // Find the two surrounding color stops
  let i = 0;
  while (i < colorStops.length - 1 && colorStops[i + 1].h < h) i++;
  if (i >= colorStops.length - 1) {
    const s = colorStops[colorStops.length - 1];
    return [s.r, s.g, s.b];
  }

  const s0 = colorStops[i];
  const s1 = colorStops[i + 1];
  const t = (h - s0.h) / (s1.h - s0.h);

  return [
    (s0.r + (s1.r - s0.r) * t) | 0,
    (s0.g + (s1.g - s0.g) * t) | 0,
    (s0.b + (s1.b - s0.b) * t) | 0
  ];
}

// --- Resize handler ---

function resize() {
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  // Scale character size for smaller screens
  FONT_SIZE = Math.max(8, Math.min(13, Math.round(W / 85)));
  CHAR_W = Math.round(FONT_SIZE * 0.77);
  CHAR_H = Math.round(FONT_SIZE * 1.23);
  FONT = `${FONT_SIZE}px "Courier New", monospace`;
  cols = Math.ceil(W / CHAR_W) + 2; // extra column for sub-pixel scroll offset
  rows = Math.ceil(H / CHAR_H) + 1;
  initHeightMap();
}

// --- Precompute color strings for performance ---
// Cache RGB strings to avoid string allocations each frame

const colorCache = new Map();

function rgbStr(r, g, b) {
  const key = (r << 16) | (g << 8) | b;
  let str = colorCache.get(key);
  if (!str) {
    str = `rgb(${r},${g},${b})`;
    colorCache.set(key, str);
    // Keep cache from growing unbounded
    if (colorCache.size > 8000) {
      // Clear oldest entries (just reset)
      colorCache.clear();
    }
  }
  return str;
}

// --- Main render loop ---

const SCROLL_SPEED = 2.0;    // cells per second of scrolling (~3.3x faster than before)
const EVOLVE_SPEED = 0.012;  // how fast terrain changes over time

// Pre-allocated buffers (re-sized in render if needed)
let bandGrid;
let interpHeights;

function render(timestamp) {
  // Delta-time in seconds, capped to prevent huge jumps on tab-switch or lag
  if (!lastFrameTime) lastFrameTime = timestamp;
  const dt = Math.min((timestamp - lastFrameTime) / 1000, 0.05);
  lastFrameTime = timestamp;

  time += dt;
  evolveTime += EVOLVE_SPEED * dt;

  // Update scroll — sub-pixel accumulation
  subPixelX += SCROLL_SPEED * dt;

  // Advance circular buffer when crossing a cell boundary
  while (subPixelX >= 1.0) {
    subPixelX -= 1.0;
    advanceHeightMap();
  }

  // Terrain evolution: update 3 columns per frame, evenly spaced across the buffer
  const evoBase = Math.floor(time * 25) % hmCols;
  for (let u = 0; u < 3; u++) {
    const logCol = (evoBase + Math.floor(u * hmCols / 3)) % hmCols;
    const physCol = (hmHead + logCol) % hmCols;
    computePhysCol(physCol, worldLeftCol + logCol);
  }

  // Clear canvas
  ctx.fillStyle = '#0a0a08';
  ctx.fillRect(0, 0, W, H);
  ctx.font = FONT;
  ctx.textBaseline = 'top';

  // Ensure buffers are large enough
  const gridSize = cols * rows;
  if (!bandGrid || bandGrid.length < gridSize) {
    bandGrid = new Int32Array(gridSize);
  }
  if (!interpHeights || interpHeights.length < gridSize) {
    interpHeights = new Float32Array(gridSize);
  }

  // Read heights and contour bands from circular buffer.
  // Sub-pixel smoothness comes from the pixel offset (scrollOff) below,
  // NOT from interpolating between heightmap columns — doing both
  // would double-count the offset and cause a back-and-forth jitter.
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const h = getHM(c, r);
      interpHeights[r * cols + c] = h;
      bandGrid[r * cols + c] = getContourBand(h);
    }
  }

  // Sub-pixel scroll offset: shift character positions for perfectly smooth motion
  const scrollOff = subPixelX * CHAR_W;

  // Render each cell
  for (let r = 0; r < rows; r++) {
    const py = r * CHAR_H;
    if (py > H) break;

    for (let c = 0; c < cols; c++) {
      const px = c * CHAR_W - scrollOff;
      if (px > W || px < -CHAR_W) continue;

      const idx = r * cols + c;
      const h = interpHeights[idx];
      const band = bandGrid[idx];

      // Neighbor bands for contour character selection
      const bandL = c > 0 ? bandGrid[idx - 1] : band;
      const bandR = c < cols - 1 ? bandGrid[idx + 1] : band;
      const bandU = r > 0 ? bandGrid[idx - cols] : band;
      const bandD = r < rows - 1 ? bandGrid[idx + cols] : band;

      const cChar = contourChar(band, bandL, bandR, bandU, bandD);

      // Soft contour blending: brightness fades smoothly near contour lines
      // instead of popping between full-bright and dim
      const hScaled = h * NUM_CONTOURS;
      const distToLine = Math.abs(hScaled - Math.round(hScaled)); // 0 at contour, 0.5 at mid-band
      const SOFT_WIDTH = 0.38;
      const rawBlend = Math.max(0, 1 - distToLine / SOFT_WIDTH);
      // Smoothstep for natural falloff
      const cBlend = rawBlend * rawBlend * (3 - 2 * rawBlend);

      // Contour character when blend is strong enough, otherwise fill
      let ch;
      if (cChar !== null && cBlend > 0.08) {
        ch = cChar;
      } else {
        ch = fillChars[Math.min(fillChars.length - 1, band)];
      }

      // Get terrain color, then blend between fill and contour brightness
      let [cr, cg, cb] = getTerrainColor(h);
      const mul = 0.8 + 1.0 * cBlend;   // 0.8 (fill) → 1.8 (contour)
      const add = 50 * cBlend;            // 0 (fill) → 50 (contour)
      cr = Math.min(255, (cr * mul + add) | 0);
      cg = Math.min(255, (cg * mul + add) | 0);
      cb = Math.min(255, (cb * mul + add) | 0);

      ctx.fillStyle = rgbStr(cr, cg, cb);
      ctx.fillText(ch, px, py);
    }
  }

  requestAnimationFrame(render);
}

// --- Events ---

window.addEventListener('resize', resize);

resize();
requestAnimationFrame((ts) => { lastFrameTime = ts; render(ts); });
</script>
</body>
</html>
