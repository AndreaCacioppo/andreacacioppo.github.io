<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>van</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a1a;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Fira Code', monospace;
  }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const TIERS = [
  [' '],
  ['.', '·', '˙'],
  [':', '∴', '⁖', ';'],
  ['-', '~', '≈', '∿'],
  ['+', '=', '±', '≡'],
  ['*', '×', '✦', '⊹'],
  ['o', '◦', '○', '❋'],
  ['#', '⊞', '▪', '◆'],
  ['%', '▓', '◉', '⬤'],
  ['@', '█', '▇', '▉'],
  ['█', '█', '▓', '▇'],
];

const SWIRL = ['~', '≈', '∿', '⌇', '∞', '∾', '≋', '⟳'];
const STAR_CH = ['✦', '✧', '⊹', '∗', '⋆', '✶', '✴'];

const CHAR_W = 9;
const CHAR_H = 15;
let W, H, cols, rows;
let gridData = null;
let cachedImg = null;

function resize() {
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  cols = Math.ceil(W / CHAR_W);
  rows = Math.ceil(H / CHAR_H);
  if (cachedImg) coarseGrain(cachedImg);
}

function hash(x, y) {
  const n = Math.sin(x * 127.1 + y * 311.7) * 43758.5453;
  return n - Math.floor(n);
}
function smoothNoise(x, y) {
  const ix = Math.floor(x), iy = Math.floor(y);
  const fx = x - ix, fy = y - iy;
  const sx = fx * fx * (3 - 2 * fx), sy = fy * fy * (3 - 2 * fy);
  return hash(ix, iy) * (1 - sx) * (1 - sy) + hash(ix + 1, iy) * sx * (1 - sy) + hash(ix, iy + 1) * (1 - sx) * sy + hash(ix + 1, iy + 1) * sx * sy;
}
function fbm(x, y, oct) {
  let v = 0, a = 0.5, f = 1;
  for (let i = 0; i < (oct || 4); i++) { v += a * smoothNoise(x * f, y * f); a *= 0.5; f *= 2; }
  return v;
}

function swirlField(nx, ny, t) {
  let angle = 0, strength = 0;
  const d1x = nx - 0.50, d1y = ny - 0.25, d1 = Math.sqrt(d1x*d1x + d1y*d1y), w1 = Math.exp(-d1 * 2.5);
  angle += (Math.atan2(d1y, d1x) + 1.57 + Math.sin(d1 * 12 - t * 0.7) * 0.9) * w1 * 2;
  strength += w1 * 2;
  const d2x = nx - 0.22, d2y = ny - 0.20, d2 = Math.sqrt(d2x*d2x + d2y*d2y), w2 = Math.exp(-d2 * 3.5);
  angle += (Math.atan2(d2y, d2x) + 1.57 + Math.sin(d2 * 14 - t) * 0.7) * w2 * 1.5;
  strength += w2 * 1.5;
  const d3x = nx - 0.82, d3y = ny - 0.14, d3 = Math.sqrt(d3x*d3x + d3y*d3y), w3 = Math.exp(-d3 * 4);
  angle += (Math.atan2(d3y, d3x) + 1.57 + Math.sin(d3 * 10 - t * 0.5) * 0.6) * w3 * 1.2;
  strength += w3 * 1.2;
  angle += Math.sin(ny * 7 + t * 0.25) * 0.35 + Math.cos(nx * 5 + t * 0.15) * 0.25;
  angle += fbm(nx * 3.5 + t * 0.08, ny * 3.5, 3) * 1.8;
  return { angle, strength: Math.min(strength, 2.5) };
}

function coarseGrain(img) {
  const off = document.createElement('canvas');
  const octx = off.getContext('2d', { willReadFrequently: true });
  const imgA = img.naturalWidth / img.naturalHeight;
  const scrA = (cols * CHAR_W) / (rows * CHAR_H);
  let sW, sH, sX, sY;
  if (imgA > scrA) { sH = img.naturalHeight; sW = Math.floor(sH * scrA); sX = Math.floor((img.naturalWidth - sW) / 2); sY = 0; }
  else { sW = img.naturalWidth; sH = Math.floor(sW / scrA); sX = 0; sY = Math.floor((img.naturalHeight - sH) / 2); }
  off.width = cols; off.height = rows;
  octx.drawImage(img, sX, sY, sW, sH, 0, 0, cols, rows);
  const px = octx.getImageData(0, 0, cols, rows).data;
  gridData = [];
  for (let r = 0; r < rows; r++) {
    const row = [];
    for (let c = 0; c < cols; c++) {
      const i = (r * cols + c) * 4;
      const R = px[i], G = px[i+1], B = px[i+2];
      row.push({ r: R, g: G, b: B, br: (R * 0.299 + G * 0.587 + B * 0.114) / 255 });
    }
    gridData.push(row);
  }
}

function pickChar(br, sStr, flow, t, c, r) {
  const ti = Math.min(Math.floor(br * TIERS.length), TIERS.length - 1);
  const tier = TIERS[ti];
  const phase = flow * 6 + t * (0.3 + sStr * 0.4) + c * 0.09 + r * 0.06;
  let ch = tier[Math.floor(Math.abs(phase)) % tier.length];
  if (sStr > 0.7 && br > 0.12 && br < 0.65 && hash(c * 0.3 + t * 0.4, r * 0.3) < (sStr - 0.7) * 2.5) {
    ch = SWIRL[Math.floor(Math.abs(phase * 1.3)) % SWIRL.length];
  }
  if (br > 0.78 && Math.sin(t * 2 + c * 0.5 + r * 0.3) > 0.2) {
    ch = STAR_CH[Math.floor(Math.abs(t * 3 + c * 0.7)) % STAR_CH.length];
  }
  return ch;
}

let time = 0;
function render() {
  time += 0.016;
  if (!gridData) { requestAnimationFrame(render); return; }
  ctx.fillStyle = '#0a0a1a';
  ctx.fillRect(0, 0, W, H);
  ctx.font = `${CHAR_H - 2}px 'Fira Code', monospace`;
  ctx.textBaseline = 'top';
  const mR = Math.min(rows, gridData.length);
  for (let r = 0; r < mR; r++) {
    const mC = Math.min(cols, gridData[r].length);
    for (let c = 0; c < mC; c++) {
      const cell = gridData[r][c];
      const nx = c / cols, ny = r / rows;
      const field = swirlField(nx, ny, time);
      const flow = fbm(nx * 4 + time * 0.12, ny * 4 + Math.sin(time * 0.08) * 0.2, 3);
      const ch = pickChar(cell.br, field.strength, flow, time, c, r);
      if (ch === ' ') continue;
      let cr = cell.r, cg = cell.g, cb = cell.b;
      if (ny < 0.6) {
        const sh = Math.sin(flow * 8 + time * 0.4 + nx * 11) * 0.1;
        const wv = Math.sin(field.angle * 2 + time * 0.3) * 12 * field.strength;
        cr = Math.min(255, Math.max(0, cr + wv + sh * 25));
        cg = Math.min(255, Math.max(0, cg + wv * 0.6 + sh * 18));
        cb = Math.min(255, Math.max(0, cb + wv * 0.3 + sh * 8));
      }
      if (cell.br > 0.65) {
        const p = Math.sin(time * 1.3 + c * 0.25 + r * 0.18) * 0.13 + 1;
        cr = Math.min(255, cr * p); cg = Math.min(255, cg * p); cb = Math.min(255, cb * p);
      }
      if (ny > 0.55 && ny < 0.72 && cell.br > 0.35 && cell.r > cell.b) {
        const fl = Math.sin(time * 4 + c * 7.3) * 0.08;
        cr = Math.min(255, cr * (1 + fl)); cg = Math.min(255, cg * (1 + fl * 0.6));
      }
      const alpha = 0.45 + cell.br * 0.55 + flow * 0.06;
      ctx.fillStyle = `rgba(${cr|0},${cg|0},${cb|0},${Math.min(1, alpha)})`;
      ctx.fillText(ch, c * CHAR_W, r * CHAR_H);
    }
  }
  requestAnimationFrame(render);
}

function loadImg() {
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = () => {
    cachedImg = img;
    resize();
    coarseGrain(img);
  };
  img.onerror = () => {
  };
  img.src = 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg/1280px-Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg';
}

window.addEventListener('resize', resize);
resize();
document.fonts.ready.then(() => { loadImg(); render(); });
</script>
</body>
</html>
